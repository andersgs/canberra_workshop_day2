#!/usr/bin/env python

'''
python seqgen2mig.py <phyfile> <migratefile> <n_inds>

Example:

./migrate_sim.py phyfile infile "10 10 10"

Takes as input the phyfile generated by seq-gen, and outputs a migrate input file with name infile.

Will assume there are three populations each with 10 sequences.

'''

import sys,numpy

#set values for variables
phyfile = sys.argv[1]

migrate_file = sys.argv[2]

n_inds = sys.argv[3]

#the main function
def parse_phy(infile,outfile,n_inds):
	#open files
	fi = open(infile,'r')
	fo = open(outfile,'w')
	
	#create some variables
	locs = []
	n_ind = n_inds.split()
	ix = numpy.cumsum([int(x) for x in n_ind])
	n_pops =len(n_ind)
	loc_lengths = ""

	#read in the data from the seq-gen file
	count = 0
	for line in fi:
		tmp = line.strip()
		if len(tmp) < 10:
			if count > 0:
				locs.append(dat)
			dat = []
			tmp=tmp.split(' ')
			loc_lengths = loc_lengths+' '+tmp[1]
			count += 1
		else:
			dat.append(line.strip())
	#make sure the last locus gets saved
	locs.append(dat)
	
	#sort the data within each locus, so that they are in order of population of origin
	for loc in range(len(locs)):
		tmp = sorted(locs[loc],key=lambda seq: int(seq[0:9]))
		locs[loc] = tmp
	
	#calculate number of loci
	n_loc = len(locs)
	
	#write out migrate infile
	#header
	fo.write('{} {} migrate sim\n'.format(n_pops,n_loc))
	##length of each locus line
	fo.write(loc_lengths+'\n')
	
	#for each population, write out the locus data for each sample
	ix_str = 0
	for p in range(n_pops):
		fo.write((str(n_ind[p])+' ')*n_loc + 'Pop {}\n'.format(p))
		ix_end = ix[p]
		for l in locs:
			for i in l[ix_str:ix_end]:
				fo.write(i+'\n')
		ix_str = ix_end

	#close files
	fi.close()
	fo.close()

#run as a standalone script
if __name__=='__main__':
	parse_phy(phyfile,migrate_file,n_inds)